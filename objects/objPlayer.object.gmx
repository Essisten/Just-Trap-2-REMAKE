<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprPlayerIdle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>sprPlayerMask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>frozen = false; //sets if the player can move or not
global.frozen = false;
jump = 8.5 * global.grav; //set how fast the player jumps
jump2 = 7 * global.grav; //sets how fast the player double jumps
gravity = 0.4 * global.grav; //player gravity
djump = 1; //allow the player to double jump as soon as he spawns
maxSpeed = 3;   //max horizontal speed
maxVspeed = 9;  //max vertical speed
HP = 1;
maxHP = 1;
image_speed = 0.2; //initial speed of animation
onPlatform = false; //sets if player is currently standing on a platform
paralyzed = false;
healthed = false;
iframe_counter = 0;
xScale = 1; //sets the direction the player is facing (1 is facing right, -1 is facing left)
sprt = sprite_index;
Just[0] = sprPlayerIdle;
Just[1] = sprPlayerRunning;
Just[2] = sprPlayerJump;
Just[3] = sprPlayerFall;
Just[4] = sprPlayerSliding;
shootUpward = false;
state = 0;
//0 - idle, 1 - run, 2 - jump, 3 - fall, 4 - sliding
global.gravH = false;
if (global.grav == -1)
    scrFlipGrav();
scrSetPlayerMask(); //set the player's hitbox
color_normal = c_white;
if (global.difficulty == 0 &amp;&amp; global.gameStarted)   //create the player's bow
    instance_create(x,y,objBow);

if (global.autosave) //save the game if currently set to autosave
{
    scrSaveGame(true);
    global.autosave = false;
}
if (!instance_exists(objWeaponPlayer))
   instance_create(x, y, objWeaponPlayer);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>objPlayer</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//when the player is destroyed, also destroy the bow
with (objBow)
    instance_destroy();
part_type_clear(global.sprintParticles);
part_emitter_clear(global.sprintParticleSystem, global.sprintEmitter);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///I-framing
if (image_alpha &gt; 0.2)
   image_alpha = 0.2;
else
    image_alpha = 1;
iframe_counter++;
if (iframe_counter &gt;= 8)
{
    image_alpha = 1;
    iframe_counter = 0;
    exit;
}
alarm[1] = 10;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Back to normal
paralyzed = false;
frozen = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if ((x &lt; 0 || x &gt; room_width || y &lt; 0 || y &gt; room_height) &amp;&amp; global.edgeDeath)  //check if player has left the room
    scrKillPlayer();

//update player sprite
if (global.playerAnimationFix)
{
    //block/vine checks
    var notOnBlock = (place_free(x,y+(global.grav)));
    var onVineR = (place_meeting(x+1,y,objWalljumpR) &amp;&amp; notOnBlock);
    var onVineL = (place_meeting(x-1,y,objWalljumpL) &amp;&amp; notOnBlock);
    
    if (!onVineR &amp;&amp; !onVineL)   //not touching any vines
    {
        if (onPlatform || !notOnBlock)  //standing on something
        {
            //check if moving left/right
            var L = (scrButtonCheck(global.leftButton) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(global.leftButton)));
            var R = (scrButtonCheck(global.rightButton) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(global.rightButton)));
            if ((L || R) &amp;&amp; !frozen)
            {
                state = 1;
                image_speed = 1/2;
            }
            else
            {
                state = 0;
                image_speed = 1/5;
            }
        }
        else    //in the air
        { 
            if ((vspeed * global.grav) &lt; 0)
            {
                state = 2;
                image_speed = 1/2;
            }
            else
            {
                state = 3;
                image_speed = 1/2;
            }
        }
    }
    else    //touching a vine
    {
        state = 4;
        image_speed = 1/2;
    }
}
if (!part_emitter_exists(global.sprintParticleSystem, global.sprintEmitter))
{
    global.sprintEmitter = part_emitter_create(global.sprintParticleSystem);
    show_message(global.sprintEmitter);
}
if (scrButtonCheck(global.sprintButton))
{
   maxSpeed = 6;
   part_type_sprite(global.sprintParticles, sprite_index, false, false, false);
   part_type_scale(global.sprintParticles, image_xscale*xScale,image_yscale*global.grav);
   part_type_orientation(global.sprintParticles, image_angle, image_angle, 0, 0, 0);
   part_emitter_region(global.sprintParticleSystem, global.sprintEmitter, x, x, y, y, global.sprintParticles, ps_distr_linear);
   //part_emitter_stream(global.sprintParticleSystem, global.sprintEmitter, global.sprintParticles, 1);
   part_emitter_burst(global.sprintParticleSystem, global.sprintEmitter, global.sprintParticles, 1);
}
else
{
   maxSpeed = 3;
   part_emitter_stream(global.sprintParticleSystem, global.sprintEmitter, global.sprintParticles, 0);
}
sprite_index = Just[state];
shootUpward = scrButtonCheck(global.upButton) &amp;&amp; !frozen;
if (paralyzed)
{
    image_speed = 0;
    if (false)
    {
        sprt = sprPlayerParalyzed;
        switch (sprite_index)
        {
            case sprPlayerRunning:
            case sprPlayerRunUp:
                image_index = 1;
                break;
            case sprPlayerFall:
            case sprPlayerFallUp:
                image_index = 2;
                break;
            case sprPlayerJump:
            case sprPlayerJumpUp:
                image_index = 3;
                break;
            default:
                image_index = 0;
                break;
        }
        sprite_index = sprt;
    }
}
if (ds_list_find_value(global.arsenal, global.currentWeapon) == 3)
{
    jump = 6 * global.grav;
    jump2 = 5 * global.grav;
    maxSpeed = 3;
    shootUpward = false;
}
else
{
    jump = 8.5 * global.grav;
    jump2 = 7 * global.grav;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//check left/right button presses
var L = (scrButtonCheck(global.leftButton) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(global.leftButton)));
var R = (scrButtonCheck(global.rightButton) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(global.rightButton)));

var h = 0;

if (!frozen)    //don't move if frozen
{
    if (R)
        h = 1;
    else if (L)
        h = -1;
}
if (!frozen)    //check if frozen before doing anything
{
    if (scrButtonCheckPressed(global.jumpButton))
        scrPlayerJump();
    if (scrButtonCheckReleased(global.jumpButton))
        scrPlayerVJump();
}
if (global.gravH)
{
    var slipBlockTouching = instance_place(x +(1*global.grav), y, objSlipBlock);   //check if on a slip block
    var slip2 = instance_place(x +(1*global.grav), y,objBoss4_Ground);
    if (slip2 != noone)
    {
        if (slip2.image_index == 3)
            slipBlockTouching = slip2;
    }
    //vine checks
    var notOnBlock = (place_free(x + (global.grav), y));
    var onVineL = (place_meeting(x, y-1, objWalljumpL) &amp;&amp; notOnBlock);
    var onVineR = (place_meeting(x, y + 1,objWalljumpR) &amp;&amp; notOnBlock);
    if (h != 0)  //player is moving
    {
        if (!onVineR &amp;&amp; !onVineL)   //make sure not currently touching a vine
        {
            xScale = h;
            if (global.gravH and global.grav == -1)
                xScale *= -1;
        }
        if ((h == -1 &amp;&amp; !onVineR) || (h == 1 &amp;&amp; !onVineL))
        {
            if (slipBlockTouching == noone) //not touching a slip block, move immediately at full speed
            {
                vspeed = maxSpeed * h * -global.grav;
            }
            else    //touching a slip block, use acceleration
            {
                vspeed += (slipBlockTouching.slip) * h * -global.grav;
                if (abs(vspeed) &gt; maxSpeed)
                    vspeed = maxSpeed * h;
            }
            state = 1;
            image_speed = 0.5;
        }
    }
    else    //player is not moving
    {
        if (slipBlockTouching == noone) //not touching a slip block, stop immediately
            vspeed = 0;
        else    //touching a slip block, slow down
        {
            if (vspeed &gt; 0)
            {
                vspeed -= slipBlockTouching.slip;
                
                if (vspeed &lt;= 0)
                    vspeed = 0;
            }
            else if (vspeed &lt; 0)
            {
                vspeed += slipBlockTouching.slip;
                
                if (vspeed &gt;= 0)
                    vspeed = 0;
            }
        }
        state = 0;
        image_speed = 0.2;
    }

    
    if (!onPlatform)    //check if standing on a platform
    {
        if((hspeed * global.grav) &lt; -0.05)
           state = 2;
        else if((hspeed * global.grav) &gt; 0.05)
           state = 3;
    }
    else
    {
        if (!place_meeting(x +(4*global.grav), y,objPlatform))
            onPlatform = false;
    }
    
    var slideBlockTouching = instance_place(x +(global.grav), y,objSlideBlock);   //check if on a slide block
    
    if (slideBlockTouching != noone)    //on a slide block, start moving with it
        vspeed += slideBlockTouching.h;
    
    if (abs(hspeed) &gt; maxVspeed)
        hspeed = sign(hspeed)*maxVspeed;    //check if moving vertically faster than max speed
    
    if (global.adAlign &amp;&amp; place_meeting(x +(global.grav), y,objBlock) &amp;&amp; !frozen)  // A/D align
    {
        
        if (scrButtonCheckPressed(global.alignLeftButton)) {vspeed --;}
        if (scrButtonCheckPressed(global.alignRightButton)) {vspeed ++;}
    }
    
    
    //walljumps
    
    if (onVineL || onVineR)
    {
        if (onVineR)
            xScale = -1;
        else
            xScale = 1;
        hspeed = 2 * global.grav;
        sprt = sprPlayerSliding;
        image_speed = 1/2;
        
        //pressed away from the vine
        if (onVineL &amp;&amp; scrButtonCheckPressed(global.rightButton)) || (onVineR &amp;&amp; scrButtonCheckPressed(global.leftButton))
        {
            if (scrButtonCheck(global.jumpButton))  //jumping off vine
            {
                if (onVineR)
                    vspeed = -15;
                else
                    vspeed = 15;
                
                hspeed = -9 * global.grav;
                audio_play_sound(sndWallJump,0,false);
                sprt = sprPlayerJump;
            }
            else    //moving off vine
            {
                if (onVineR)
                    vspeed = -3;
                else
                    vspeed = 3;
                state = 3;
            }
        }
    }
    
    //slopes
    
    if (instance_exists(objSlope) &amp;&amp; vspeed != 0)
    {
        var moveLimit = abs(vspeed);
        //sets how high/low the player can go to snap onto a slope, this can be increased to make the player able to run over steeper slopes (ie setting it to abs(hspeed)*2 allows the player to run over slopes twice as steep)
        
        var slopeCheck;
        var hTest;
        
        var ySlope;
        
        //falling onto a slope
        if (place_meeting(x+hspeed+ gravity,y+vspeed,objSlope) &amp;&amp; (hspeed+gravity)*global.grav &gt; 0 &amp;&amp; notOnBlock)
        {
            var xLast = x;
            var yLast = y;
            var hLast = hspeed;
            var vLast = vspeed;
            
            hspeed += gravity;
            
            x += hspeed;
            hspeed = 0;
            
            if(!place_free(x+hspeed, y))
            {
                if (global.grav)   //normal
                    move_contact_solid(180,abs(hspeed));
                else    //flipped
                    move_contact_solid(270,abs(hspeed));
                hspeed = 0;
            }
            
            y += vspeed;            
            
            if (!place_free(x+(global.grav), y) &amp;&amp; place_free(x,y))  //snapped onto the slope properly
            {
                djump = 1;
                notOnBlock = false;
            }
            else    //did not snap onto the slope, return to previous position
            {
                x = xLast;
                y = yLast;
                hspeed = hLast;
                vspeed = vLast;
            }
        }
        
        //moving down a slope
        if (!notOnBlock)
        {
            var onSlope = (place_meeting(x +(global.grav), y,objSlope));    //treat normal blocks the same as slopes if we're standing on a slope
            
            slopeCheck = true;
            hTest = vspeed;
            
            while (slopeCheck)
            {
                ySlope = 0;
                //check how far we should move down
                while ((!place_meeting(x-ySlope+(global.grav), y + hTest,objSlope) ||
                (onSlope &amp;&amp; !place_meeting(x - ySlope+(global.grav), y + hTest,objBlock))) &amp;&amp;
                ySlope*global.grav &gt; -floor(moveLimit*(hTest/vspeed)))
                {
                    ySlope -= global.grav;
                }
                
                //check if we actually need to move down
                if (place_meeting(x -ySlope+(global.grav), y + hTest,objSlope) ||
                (onSlope &amp;&amp; place_meeting(x -ySlope+(global.grav), y + hTest,objBlock)))
                {
                    if (ySlope != 0 &amp;&amp; !place_meeting(x-ySlope, y + hTest, objBlock))
                    {
                        x -= ySlope;
                        y += hTest;
                        vspeed = 0;
                        
                        slopeCheck = false;
                    }
                    else
                    {
                        if (hTest &gt; 0)
                        {
                            hTest -= 1;
                            if (hTest &lt;= 0)
                                slopeCheck = false;
                        }
                        else if (hTest &lt; 0)
                        {
                            hTest += 1;
                            if (hTest &gt;= 0)
                                slopeCheck = false;
                        }
                        else
                        {
                            slopeCheck = false;
                        }
                    }
                }
                else
                {
                    slopeCheck = false;
                }
            }
        }
        
        //moving up a slope
        if (place_meeting(x, y + vspeed,objSlope))
        {
            slopeCheck = true;
            hTest = vspeed;
            
            while (slopeCheck)
            {
                ySlope = 0;
                
                //check how far we have to move up
                while (place_meeting(x-ySlope, y + hTest,objSlope) &amp;&amp;
                ySlope*global.grav &lt; floor(moveLimit*(hTest/vspeed)))
                {
                    ySlope += global.grav;
                }
                
                //check if we actually need to move up
                if (place_free(x -ySlope, y + hTest))
                {            
                    x -= ySlope;
                    y += hTest;
                    vspeed = 0;
                    slopeCheck = false;
                }
                else
                {
                    if (hTest &gt; 0)
                    {
                        hTest -= 1;
                        if (hTest &lt;= 0)
                            slopeCheck = false;
                    }
                    else if (hTest &lt; 0)
                    {
                        hTest += 1;
                        if (hTest &gt;= 0)
                            slopeCheck = false;
                    }
                    else
                    {
                        slopeCheck = false;
                    }
                }
            }
        }
        
        //set xprevious/yprevious coordinates for future solid collisions
        xprevious = x;
        yprevious = y;
    }
}
else
{
    var slipBlockTouching = instance_place(x,y+(1*global.grav),objSlipBlock);   //check if on a slip block
    var slip2 = instance_place(x,y+(1*global.grav),objBoss4_Ground);
    if (slip2 != noone)
    {
        if (slip2.image_index == 3)
            slipBlockTouching = slip2;
    }
    //vine checks
    var notOnBlock = (place_free(x,y+(global.grav)));
    var onVineL = (place_meeting(x-1,y,objWalljumpL) &amp;&amp; notOnBlock);
    var onVineR = (place_meeting(x+1,y,objWalljumpR) &amp;&amp; notOnBlock);
    
    if (h != 0)  //player is moving
    {
        if (!onVineR &amp;&amp; !onVineL)   //make sure not currently touching a vine
        {
            xScale = h;
        }
        if ((h == -1 &amp;&amp; !onVineR) || (h == 1 &amp;&amp; !onVineL))
        {
            if (slipBlockTouching == noone) //not touching a slip block, move immediately at full speed
            {
                hspeed = maxSpeed * h;
            }
            else    //touching a slip block, use acceleration
            {
                hspeed += (slipBlockTouching.slip) * h;
                
                if (abs(hspeed) &gt; maxSpeed)
                    hspeed = maxSpeed * h;
            }
            state = 1;
            image_speed = 0.5;
        }
    }
    else    //player is not moving
    {
        if (slipBlockTouching == noone) //not touching a slip block, stop immediately
            hspeed = 0;
        else    //touching a slip block, slow down
        {
            if (hspeed &gt; 0)
            {
                hspeed -= slipBlockTouching.slip;
                
                if (hspeed &lt;= 0)
                    hspeed = 0;
            }
            else if (hspeed &lt; 0)
            {
                hspeed += slipBlockTouching.slip;
                
                if (hspeed &gt;= 0)
                    hspeed = 0;
            }
        }
        state = 0;
        image_speed = 0.2;
    }
    
    
    if (!onPlatform)    //check if standing on a platform
    {
        if((vspeed * global.grav) &lt; -0.05)
           state = 2;
        else if((vspeed * global.grav) &gt; 0.05)
           state = 3;
    }
    else
    {
        if (!place_meeting(x,y+(4*global.grav),objPlatform)) {onPlatform = false;}
    }
    
    var slideBlockTouching = instance_place(x,y+(global.grav),objSlideBlock);   //check if on a slide block
    
    if (slideBlockTouching != noone)    //on a slide block, start moving with it
        hspeed += slideBlockTouching.h;
    
    if (abs(vspeed) &gt; maxVspeed) {vspeed = sign(vspeed)*maxVspeed;} //check if moving vertically faster than max speed

    if (global.adAlign &amp;&amp; place_meeting(x,y+(global.grav),objBlock) &amp;&amp; !frozen)  // A/D align
    {
        if (scrButtonCheckPressed(global.alignLeftButton)) {hspeed -= 1;}
        if (scrButtonCheckPressed(global.alignRightButton)) {hspeed += 1;}
    }
    
    
    //walljumps
    
    if (onVineL || onVineR)
    {
        if (onVineR)
            xScale = -1;
        else
            xScale = 1;
        
        vspeed = 2 * global.grav;
        state = 4;
        image_speed = 1/2;
        
        //pressed away from the vine
        if (onVineL &amp;&amp; scrButtonCheckPressed(global.rightButton)) || (onVineR &amp;&amp; scrButtonCheckPressed(global.leftButton))
        {
            if (scrButtonCheck(global.jumpButton))  //jumping off vine
            {
                if (onVineR)
                    hspeed = -15;
                else
                    hspeed = 15;
                
                vspeed = -9 * global.grav;
                audio_play_sound(sndWallJump,0,false);
                state = 2;
            }
            else    //moving off vine
            {
                if (onVineR)
                    hspeed = -3;
                else
                    hspeed = 3;
                state = 3;
            }
        }
    }
    
    //slopes
    
    if (instance_exists(objSlope) &amp;&amp; hspeed != 0)
    {
        var moveLimit = abs(hspeed);    //sets how high/low the player can go to snap onto a slope, this can be increased to make the player able to run over steeper slopes (ie setting it to abs(hspeed)*2 allows the player to run over slopes twice as steep)
        
        var slopeCheck;
        var hTest;
        
        var ySlope;
        
        //falling onto a slope
        if (place_meeting(x+hspeed,y+vspeed+gravity,objSlope) &amp;&amp; (vspeed+gravity)*global.grav &gt; 0 &amp;&amp; notOnBlock)
        {
            var xLast = x;
            var yLast = y;
            var hLast = hspeed;
            var vLast = vspeed;
            
            vspeed += gravity;
            
            x += hspeed;
            hspeed = 0;
            
            if(!place_free(x,y+vspeed))
            {
                if (global.grav == 1)   //normal
                    move_contact_solid(270,abs(vspeed));
                else    //flipped
                    move_contact_solid(90,abs(vspeed));
                vspeed = 0;
            }
            
            y += vspeed;            
            
            if (!place_free(x,y+(global.grav)) &amp;&amp; place_free(x,y))  //snapped onto the slope properly
            {
                djump = 1;
                notOnBlock = false;
            }
            else    //did not snap onto the slope, return to previous position
            {
                x = xLast;
                y = yLast;
                hspeed = hLast;
                vspeed = vLast;
            }
        }
        
        //moving down a slope
        if (!notOnBlock)
        {
            var onSlope = (place_meeting(x,y+(global.grav),objSlope));    //treat normal blocks the same as slopes if we're standing on a slope
            
            slopeCheck = true;
            hTest = hspeed;
            
            while (slopeCheck)
            {
                ySlope = 0;
                //check how far we should move down
                while ((!place_meeting(x+hTest,y-ySlope+(global.grav),objSlope) || (onSlope &amp;&amp; !place_meeting(x+hTest,y-ySlope+(global.grav),objBlock))) &amp;&amp; ySlope*global.grav &gt; -floor(moveLimit*(hTest/hspeed)))
                {
                    ySlope -= global.grav;
                }
                
                //check if we actually need to move down
                if (place_meeting(x+hTest,y-ySlope+(global.grav),objSlope) || (onSlope &amp;&amp; place_meeting(x+hTest,y-ySlope+(global.grav),objBlock)))
                {
                    if (ySlope != 0 &amp;&amp; !place_meeting(x+hTest,y-ySlope,objBlock))
                    {
                        y -= ySlope;
                        
                        x += hTest;
                        hspeed = 0;
                        
                        slopeCheck = false;
                    }
                    else
                    {
                        if (hTest &gt; 0)
                        {
                            hTest -= 1;
                            if (hTest &lt;= 0)
                                slopeCheck = false;
                        }
                        else if (hTest &lt; 0)
                        {
                            hTest += 1;
                            if (hTest &gt;= 0)
                                slopeCheck = false;
                        }
                        else
                        {
                            slopeCheck = false;
                        }
                    }
                }
                else
                {
                    slopeCheck = false;
                }
            }
        }
        
        //moving up a slope
        if (place_meeting(x+hspeed,y,objSlope))
        {
            slopeCheck = true;
            hTest = hspeed;
            
            while (slopeCheck)
            {
                ySlope = 0;
                
                //check how far we have to move up
                while (place_meeting(x+hTest,y-ySlope,objSlope) &amp;&amp; ySlope*global.grav &lt; floor(moveLimit*(hTest/hspeed)))
                {
                    ySlope += global.grav;
                }
                
                //check if we actually need to move up
                if (place_free(x+hTest,y-ySlope))
                {            
                    y -= ySlope;
                    
                    x += hTest;
                    hspeed = 0;
                    
                    slopeCheck = false;
                }
                else
                {
                    if (hTest &gt; 0)
                    {
                        hTest -= 1;
                        if (hTest &lt;= 0)
                            slopeCheck = false;
                    }
                    else if (hTest &lt; 0)
                    {
                        hTest += 1;
                        if (hTest &gt;= 0)
                            slopeCheck = false;
                    }
                    else
                    {
                        slopeCheck = false;
                    }
                }
            }
        }
        
        //set xprevious/yprevious coordinates for future solid collisions
        xprevious = x;
        yprevious = y;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objParalyzer">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Paralyze the player
instance_destroy(other);
alarm[0] = 50 + global.difficulty * 25;
if (paralyzed)
   exit;
frozen = true;
paralyzed = true;
exit;
with (objWeaponPlayer)
{
    sprite_index = paralyzed[other.state];
    if (other.shootUpward)
       sprite_index = sprWeaponUp_Paralyzed;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objPlayerKiller">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (alarm[1] &gt; -1)
   exit;
if (!healthed)
{
   scrKillPlayer();
   exit;
}
scrDamagePlayer(1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objPlatform">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.gravH)
{
    if (global.grav == 1)   //normal
    {
        if (x-hspeed/2 &lt;= other.h)
        {
            if (other.hspeed &gt;= 0)
            {
                x = other.x - 9;
                hspeed = other.hspeed;
            }
            
            onPlatform = true;
            djump = 1;
        }
    }
    else    //flipped
    {
        if (x-hspeed/2 &gt;= other.x+other.sprite_height-1)
        {
            if (other.yspeed &lt;= 0)
            {
                x = other.x + other.sprite_height+8;
                hspeed = other.yspeed;
            }
            
            onPlatform = true;
            djump = 1;
        }
    }
}
else
{
    if (global.grav == 1)   //normal
    {
        if (y-vspeed/2 &lt;= other.y)
        {
            if (other.vspeed &gt;= 0)
            {
                y = other.y-9;
                vspeed = other.vspeed;
            }
            
            onPlatform = true;
            djump = 1;
        }
    }
    else    //flipped
    {
        if (y-vspeed/2 &gt;= other.y+other.sprite_height-1)
        {
            if (other.yspeed &lt;= 0)
            {
                y = other.y+other.sprite_height+8;
                vspeed = other.yspeed;
            }
            
            onPlatform = true;
            djump = 1;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objBlock">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!place_free(x+hspeed,y))
{
    if (global.grav == 1)   //normal
    {
        if(hspeed &lt;= 0)move_contact_solid(180,abs(hspeed))
        if(hspeed &gt; 0) move_contact_solid(0,abs(hspeed))
    }
    else    //flipped
    {
        if(hspeed &lt; 0){move_contact_solid(180,abs(hspeed));}
        if(hspeed &gt;= 0){move_contact_solid(0,abs(hspeed));}
    }
    hspeed = 0;
}
if (!place_free(x,y+vspeed))
{
    if (global.grav == 1)   //normal
    {
        if(vspeed &lt;= 0)move_contact_solid(90,abs(vspeed));
        if(vspeed &gt; 0) move_contact_solid(270,abs(vspeed));
    }
    else    //flipped
    {
        if(vspeed &lt;= 0)move_contact_solid(90,abs(vspeed))
        if(vspeed &gt; 0) move_contact_solid(270,abs(vspeed))
    }
    vspeed = 0;
    djump = 1;
}

if (!place_free(x+hspeed,y+vspeed))
   hspeed = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!instance_exists(objWeaponPlayer))
   instance_create(x, y, objWeaponPlayer);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///bruh
if (room == rBoss2)
{
    if (x &lt; 0)
        x = 128;
    else if (x &gt; 800)
        x = 672;
    if (y &lt; 0)
        y = 128;
    else if (y &gt; 608)
        y = 480;
    scrPlaySound(sndAppearV);
    instance_create(0, 0, objLightEffect);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw the player
if (paralyzed)
   shader_set(shdGrayscale);
var drawX = x;
var drawY = y;
if (global.grav == -1)      //need to draw the player a pixel off in the y-axis when flipped for some reason
    drawY += 1;
draw_sprite_ext(sprite_index,image_index,drawX,drawY,image_xscale*xScale,image_yscale*global.grav,image_angle,image_blend,image_alpha);
shader_reset();
//draw the player's hitbox
if (global.debugShowHitbox)
    draw_sprite_ext(mask_index,image_index,x,y,image_xscale,image_yscale,image_angle,image_blend,image_alpha*0.8);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="52">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.debugMode)
   scrSetGrav(4);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="51">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.debugMode)
   scrSetGrav(3);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="50">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.debugMode)
   scrSetGrav(2);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="49">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.debugMode)
   scrSetGrav(1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
